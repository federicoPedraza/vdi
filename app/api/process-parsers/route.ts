import { NextRequest, NextResponse } from "next/server";
import { ConvexHttpClient } from "convex/browser";
import { api } from "../../../convex/_generated/api";
import { Ollama } from "ollama";

const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

async function generateParserCode(platform: string, event: string, payload: any): Promise<string> {
  const ollama = new Ollama({ host: "http://localhost:11434" });
  const language = "javascript";

  // Prepare the system prompt with order schema information
  const systemPrompt = `You are an expert developer that creates parsers to convert webhook payloads to a specific database schema.

TARGET SCHEMA - Convert webhook payload to this exact structure:

CLIENT SCHEMA:
{
  email?: string,
  phone?: string,
  firstName?: string,
  lastName?: string,
  platformId: string, // ID from the external platform
  platform: string, // platform name like "vii", "shopify", etc.
  address?: {
    street?: string,
    city?: string,
    state?: string,
    country?: string,
    zipCode?: string,
  },
  storeId?: string,
}

ORDER SCHEMA:
{
  platformOrderId: string, // Order ID from external platform
  platform: string, // platform name
  orderNumber?: string,
  status: string, // "pending", "paid", "fulfilled", "cancelled", etc.
  total: number,
  currency: string,
  orderDate: number, // timestamp
  paidDate?: number, // timestamp if paid
  fulfilledDate?: number, // timestamp if fulfilled
  notes?: string,
  paymentMethod?: string,
  storeId?: string,
}

SHIPPING SCHEMA (if applicable):
{
  trackingNumber?: string,
  carrier?: string,
  status: string, // "pending", "shipped", "delivered", "returned"
  shippedDate?: number, // timestamp
  deliveredDate?: number, // timestamp
  shippingAddress: {
    firstName?: string,
    lastName?: string,
    street?: string,
    city?: string,
    state?: string,
    country?: string,
    zipCode?: string,
    phone?: string,
  },
  platform: string,
}

ORDER_LINES SCHEMA (if applicable):
{
  productId?: string,
  sku?: string,
  productName: string,
  quantity: number,
  unitPrice: number,
  totalPrice: number,
  platform: string,
}

INSTRUCTIONS:
1. Create a ${language} function that takes a webhook payload and returns an object with:
   - client: CLIENT_SCHEMA object
   - order: ORDER_SCHEMA object
   - shipping?: SHIPPING_SCHEMA object - only if shipping info exists
   - orderLines?: Array of ORDER_LINES_SCHEMA objects - only if line items exist

2. Handle missing fields gracefully - use fallback values or undefined
3. Convert dates to timestamps (milliseconds since epoch)
4. Ensure required fields are always present with sensible defaults
5. Make the function robust - handle different payload structures
6. Return only the function code, no explanations
7. Function should be named 'exec'
8. Handle errors gracefully and return null for unparseable data

Example structure:
\`\`\`${language}
function exec(payload) {
  try {
    // Extract and transform data here
    return {
      client: { /* CLIENT_SCHEMA */ },
      order: { /* ORDER_SCHEMA */ },
      shipping: { /* SHIPPING_SCHEMA */ }, // optional
      orderLines: [ /* ORDER_LINES_SCHEMA */ ] // optional
    };
  } catch (error) {
    console.error('Parser error:', error);
    return null;
  }
}
\`\`\``;

  const userPrompt = `Generate a parser for this webhook payload:

Platform: ${platform}
Event: ${event}

Payload:
${JSON.stringify(payload, null, 2)}

Generate ONLY the function code in ${language}. No explanations, no markdown formatting, just the raw function code.`;

  // Generate parser code using Ollama
  const response = await ollama.chat({
    model: "gpt-oss:20b",
    messages: [
      { role: "system", content: systemPrompt },
      { role: "user", content: userPrompt },
    ],
  });

  const generatedCode = response.message.content;

  if (!generatedCode) {
    throw new Error("No parser code generated by AI");
  }

  return generatedCode;
}

export async function POST(request: NextRequest) {
  try {
    console.log('üîÑ Processing pending parsers...');

    // Get all parsers with "building" state
    const buildingParsers = await convex.query(api.procedures.getBuildingParsers);

    if (buildingParsers.length === 0) {
      console.log('‚úÖ No pending parsers to process');
      return NextResponse.json({
        message: "No pending parsers to process",
        processed: 0
      });
    }

    console.log(`üìã Found ${buildingParsers.length} pending parsers to process`);

    const results = [];

        // Process each building parser
    for (const parser of buildingParsers) {
      try {
        console.log(`üîÑ Processing parser: ${parser.name} (${parser.uuid})`);

        // Generate parser code using Ollama
        console.log(`   Generating code with Ollama...`);
        const generatedCode = await generateParserCode(
          parser.platform || "unknown",
          parser.event || "webhook",
          parser.originalPayload
        );

        console.log(`   Code generated, executing parser...`);

        // Execute the parser with the original payload
        const parseFunction = new Function(
          "payload",
          `${generatedCode}\nreturn exec(payload);`
        );

        const result = parseFunction(parser.originalPayload);

        if (result && result.client && result.order) {
          // Update the parser with the generated code first
          await convex.mutation(api.procedures.updateParserCode, {
            parserId: parser._id,
            code: generatedCode,
          });

          // Now process the parsed data using the existing processBuildingParser action
          await convex.action(api.procedures.processBuildingParser, {
            parserId: parser._id,
          });

          results.push({
            parserId: parser._id,
            parserName: parser.name,
            parserUuid: parser.uuid,
            status: "success",
          });

          console.log(`‚úÖ Parser ${parser.name} processed successfully`);
        } else {
          throw new Error("Parser execution failed - invalid result structure");
        }
      } catch (error) {
        console.error(`‚ùå Failed to process parser ${parser.name}:`, error);

        // Update parser to failed state
        try {
          await convex.mutation(api.procedures.updateParserFailedPublic, {
            parserId: parser._id,
            error: error instanceof Error ? error.message : "Unknown error",
          });
        } catch (updateError) {
          console.error(`Failed to update parser state:`, updateError);
        }

        results.push({
          parserId: parser._id,
          parserName: parser.name,
          parserUuid: parser.uuid,
          status: "failed",
          error: error instanceof Error ? error.message : "Unknown error",
        });
      }
    }

    const successCount = results.filter(r => r.status === "success").length;
    const failedCount = results.filter(r => r.status === "failed").length;

    console.log(`üìä Processing complete: ${successCount} successful, ${failedCount} failed`);

    return NextResponse.json({
      message: "Parser processing complete",
      processed: buildingParsers.length,
      successCount,
      failedCount,
      results,
    });

  } catch (error) {
    console.error('‚ùå Error processing parsers:', error);
    return NextResponse.json(
      {
        error: "Failed to process parsers",
        details: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    // Get all parsers with "building" state
    const buildingParsers = await convex.query(api.procedures.getBuildingParsers);

    return NextResponse.json({
      message: "Pending parsers retrieved",
      count: buildingParsers.length,
      parsers: buildingParsers.map(parser => ({
        id: parser._id,
        name: parser.name,
        uuid: parser.uuid,
        platform: parser.platform,
        event: parser.event,
      })),
    });

  } catch (error) {
    console.error('‚ùå Error retrieving pending parsers:', error);
    return NextResponse.json(
      {
        error: "Failed to retrieve pending parsers",
        details: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
}
